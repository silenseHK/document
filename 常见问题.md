### 问题描述:

>同时操作[两个功能，如a功能提现驳回操作余额,b功能购买商品操作余额,由于是同时操作，并没有设置锁，导致购买了商品之后的余额反而比购买之前还要多]数据库一条数据影响。

#### 处理方法

> 在修改数据的时候添加写锁，锁只有在事务中才会生效，但是如果生成锁之后，任何地方都会有效果，知道事务结束或者请求被取消。

#### laravel处理

> ```php
> DB::transaction(function(){
>     DB::table("users")->where("id","379")->lockForUpdate()->first(); //这里是添加写锁
> });
> 
> DB::transaction(function(){
> 	DB::table("users")->where("id","379")->sharedLock()->first();  //这里是添加读锁
> });
> ```

#### mysql 事务隔离级别

![img](https://img-blog.csdn.net/20180222160026154)

> mysql的默认隔离级别是 【可重复读】,这就导致了出现上面的问题

> 1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
>
> 2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。
>
> 3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A   	改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
>
> 小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表